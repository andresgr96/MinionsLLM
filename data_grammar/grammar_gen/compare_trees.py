import xml.etree.ElementTree as ET
from typing import List, Optional, Tuple


def validate_node_recursive(
    orig_node: ET.Element,
    gen_node: ET.Element,
    conditions: Optional[List[str]] = None,
    actuator_actions: Optional[List[str]] = None,
    state_actions: Optional[List[str]] = None,
    feedback: Optional[List[str]] = None,
    path: str = "",
) -> bool:
    if feedback is None:
        feedback = []

    current_path = f"{path}/{orig_node.tag}" if path else orig_node.tag

    # Check if node tags match
    if orig_node.tag != gen_node.tag:
        feedback.append(
            f"Node tag mismatch at {current_path}: expected '{orig_node.tag}' but got '{gen_node.tag}'"
        )
        return False

    # Check content type if node has content
    if gen_node.text and gen_node.text.strip():
        content = gen_node.text.strip()
        if (
            gen_node.tag == "Condition"
            and conditions is not None
            and content not in conditions
        ):
            feedback.append(
                f"Invalid condition content at {current_path}: '{content}' is not a valid condition"
            )
            return False
        elif (
            gen_node.tag == "ActuatorAction"
            and actuator_actions is not None
            and content not in actuator_actions
        ):
            feedback.append(
                f"Invalid actuator action at {current_path}: '{content}' is not a valid actuator action"
            )
            return False
        elif (
            gen_node.tag == "StateAction"
            and state_actions is not None
            and content not in state_actions
        ):
            feedback.append(
                f"Invalid state action at {current_path}: '{content}' is not a valid state action"
            )
            return False

    # Check if number of children match
    if len(orig_node) != len(gen_node):
        feedback.append(
            f"Number of children mismatch at {current_path}: expected {len(orig_node)} but got {len(gen_node)}"
        )
        return False

    # Recursively validate all children
    return all(
        validate_node_recursive(
            orig_child,
            gen_child,
            conditions,
            actuator_actions,
            state_actions,
            feedback,
            current_path,
        )
        for orig_child, gen_child in zip(orig_node, gen_node)
    )


def validate_tree_structure(
    original_tree: str,
    generated_tree: str,
    conditions: Optional[List[str]] = None,
    actuator_actions: Optional[List[str]] = None,
    state_actions: Optional[List[str]] = None,
) -> Tuple[bool, str]:
    """
    Validates that the generated tree matches the structure of the original tree
    and that node contents match their expected types.

    Args:
        original_tree: The original template tree string
        generated_tree: The tree string generated by the LLM
        conditions: List of valid condition nodes
        actuator_actions: List of valid actuator actions
        state_actions: List of valid state actions

    Returns:
        tuple[bool, str]: (is_valid, feedback_message)
    """
    feedback: List[str] = []
    try:
        # Parse both trees
        try:
            original_root = ET.fromstring(original_tree)
        except ET.ParseError as e:
            return False, f"Original tree parsing error: {str(e)}"

        try:
            generated_root = ET.fromstring(generated_tree)
        except ET.ParseError as e:
            return (
                False,
                f"Generated tree parsing error at line {e.position[0]}, column {e.position[1]}: {str(e)}",
            )

        is_valid = validate_node_recursive(
            original_root,
            generated_root,
            conditions,
            actuator_actions,
            state_actions,
            feedback,
        )
        return is_valid, "\n".join(feedback) if feedback else ""

    except Exception as e:
        return False, f"Unexpected validation error: {str(e)}"
